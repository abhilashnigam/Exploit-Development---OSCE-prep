#!/usr/bin/python
import array
import time
import sys
from tabulate import tabulate

def calculateSubDigits(val):
	col = 0
	for item in val:
		intValue = int(item,16)
		if intValue <=54 or intValue == 0:
			pass
			if col<=2:
				pass
				val[col+1] = hex(int(val[col+1],16) - 1)
			split_Integer(intValue + 256, col)
		else:
			pass
			split_Integer(intValue, col)
		col += 1
	print (tabulate(matrix, headers, tablefmt="grid"))
	

def split_Integer(val,col):
	pass
	arr = [i for i in range(1,val+1)]
	for i1 in list(badchar):
		if (int(i1) in arr):
			pass
			arr.remove(int(i1))
	for i in list(arr):
		if (hex(i).find("f")>0):
			arr.remove(i)

	l=len(arr)
	for i in range(0,l):
		pass
		for j in range(1,l//3):
			pass
			for k in range(1,l//3):
				pass
				if ((arr[i]+arr[j]+arr[k])==val and (arr[i] > 4 and arr[j] > 5 and arr[k] > 5)):
					pass
					matrix[col][1] = "%02x" %arr[i]
					matrix[col][2] = "%02x" %arr[j]
					matrix[col][3] = "%02x" %arr[k]
					return
	print("nothing")

def opCodeWrite():
	global opCode
	localopCode = ""
	if ch == "1":
		pass
		localopCode += 'encoded += "\\x25\\x4A\\x4D\\x4E\\x55"\t\t\t\t#AND EAX,554E4D4A	-> zero out eax\r\n'
		localopCode += 'encoded += "\\x25\\x35\\x32\\x31\\x2A"\t\t\t\t#AND EAX,2A313235	-> zero out eax\r\n'

	for i in range(1,4):
		cellValue = ""
		revCellValue = ""
		pass
		cnt = 3
		for j in range(0,4):
			pass
			cellValue += "\\x"+matrix[j][i]
			revCellValue += matrix[cnt][i]
			cnt = cnt - 1
		localopCode += 'encoded += "\\x2D' + cellValue + '"\t\t\t\t#SUB EAX, 0x' + revCellValue + '\t-> Calculating \r\n'


	localopCode += 'encoded += "\\x50"\t\t\t\t\t\t#Push EAX\r\n'
	opCode += localopCode 

def usage():
    print ()
    print ("************************************************SubEncoder**********************************************")
    print ()
    print ("Developed by @oathk33p3r")
    print ("Usage python SubEncoder.py")
    print ()
    print ("\t-h for Help ")
    print ()
    print ("Example")
    print ("python3 subencoder.py")
    print ("Current Opcodes in 4 bytes chunk: \\x75\\xe7\\xff\\xe7")
    print ()
    print ("Note: If encoding ESP Address get the address of ESP in EAX register prior to running this script")
    print ()
    print ("********************************************************************************************************")
    sys.exit(0)

def stackAlign():
	pass
	addressHex = input("Enter the new stack address:  ")
	if "0x" in addressHex:
		pass
		addressHex = addressHex.replace("0x","")

	elif "\\x" in addressHex:
		pass
		addressHex = addressHex.replace("\\x","")
	else:
		print("Please enter address in \"0x90\" or \"\\x90\" format")
		exit(1)
	addressHex = addressHex.replace("'","")
	addressHex = addressHex.replace('"',"")
	addressHex = addressHex.zfill(8)
	print ("Checking Stack Value alignment...")
	quot,remain = divmod(int(addressHex,16),4)
	if remain>0:
		pass
		while True:
			pass
			quot,remain = divmod(int(addressHex,16),4)
			if remain==0:

				addressHex = addressHex.zfill(8)
				break
			else:
				x=int(addressHex,16) 
				x= x+1
				x= hex(x)
				x=x.replace("0x","")
				addressHex = x
		# print (addressHex)
		time.sleep(1)
		print("[◀] Stack is not aligned\r\n[◎] Aligning stack to a new address.\r\n")
		time.sleep(1)
		print("[◎] New Stack Address is 0x" +addressHex)
	else:
		print("[▶] Stack Address aligned\r\n")\

	# addressHex = "".join(reversed([addressHex[i:i+2] for i in range(0, len(addressHex), 2)]))				#reverse shellcode in hex from now on. => ["04030201"]	
	subRes = int("ffffffff",16) - int(addressHex,16) + 1
	subResHex = hex(subRes)
	subResHex = subResHex[2:].zfill(8)
	print ("********************************************************************************************************")
	print ("Encoding Address bytes = 0x" + addressHex)
	print ("--------------------------------------------------------------------------------------------------------")
	time.sleep(1)
	print ("[◎] Calculation = 0xFFFFFFFF - 0x" + addressHex + " + 1 = " + subResHex) 
	subResPair = [subResHex[i:i+2] for i in range(0, len(subResHex), 2)]									#"1800188b" => ['0x', '18', '00', '18', '8b']
	subResPair = [ele for ele in reversed(subResPair)]
	for x in range(0, 4):
		matrix[x][0] = subResPair[x]
	calculateSubDigits(subResPair)
	opCodeWrite()
	time.sleep(1)
	print ("********************************************************************************************************")


def subEncoder():
	shellCodeHex = input("Enter shellcode to be encoded:  ")
	if "0x" in shellCodeHex:
		pass
		shellCodeHex = shellCodeHex.replace("0x","")

	elif "\\x" in shellCodeHex:
		pass
		shellCodeHex = shellCodeHex.replace("\\x","")
	else:
		print("Please enter shellcode in \"0x90\" or \"\\x90\" format")
		exit(1)
	shellCodeHex = shellCodeHex.replace("'","")
	shellCodeHex = shellCodeHex.replace('"',"")

	# breaking 
	shellCodeHexPair = ''
	shellCodeHexPair = [shellCodeHex[i:i+2] for i in range(0, len(shellCodeHex), 2)]		#"90909090" => ["90","90","90","90"]
	if len(shellCodeHexPair) % 4 != 0:
		print ("[◀] Shellcode size is not divisible by 4")
		time.sleep(1)

		if ((len(shellCodeHexPair))+1) % 4 == 0:
			shellCodeHex += "90"
			print ("[▶] Adding Padding shellcode with 1 NOPS..")
			time.sleep(1)		
		elif ((len(shellCodeHexPair))+2) % 4 == 0:
			shellCodeHex += "90"
			shellCodeHex += "90"
			print ("[▶] Adding shellcode with 2 NOPS..")
			time.sleep(1)
		else:
			shellCodeHex += "90"
			shellCodeHex += "90"
			shellCodeHex += "90"
			print ("[▶] Adding shellcode with 3 NOPS..")
			time.sleep(1)
	else:
		print ("[‣] Shellcode size is divisible by 4")

	shellCodeHex = "".join(reversed([shellCodeHex[i:i+2] for i in range(0, len(shellCodeHex), 2)]))				#reverse shellcode in hex from now on. => ["04030201"]
	shellCodeHexPair = [shellCodeHex[i:i+8] for i in range(0, len(shellCodeHex), 8)]
	
	for inst in shellCodeHexPair:
		subRes = int("ffffffff",16) - int(inst,16) + 1
		subResHex = hex(subRes)
		subResHex = subResHex[2:].zfill(8)
		print ("********************************************************************************************************")
		print ("Encoding 4 bytes = 0x" + inst)
		print ("--------------------------------------------------------------------------------------------------------")
		time.sleep(1)
		print ("[◎] Calculation = 0xFFFFFFFF - 0x" + inst + " + 1 = " + subResHex) 
		subResPair = [subResHex[i:i+2] for i in range(0, len(subResHex), 2)]									#"1800188b" => ['0x', '18', '00', '18', '8b']
		subResPair = [ele for ele in reversed(subResPair)]
		for x in range(0, 4):
			matrix[x][0] = subResPair[x]
		calculateSubDigits(subResPair)
		opCodeWrite()
		time.sleep(1)
		print ("********************************************************************************************************")

if __name__ == '__main__':
	global matrix
	global headers
	global opCode
	
	badchar=[int("0a",16), int("0d",16), 0, int("2e",16), int("15",16), int("40",16)]
	opCode = 'encoded =  ""\r\n'
	matrix = [[0 for x in range(4)] for y in range(4)]						#matrix[row][column]
	headers = ["A","B", "C", "D"]
	try:
		pass
		argLen = len(sys.argv)
		if argLen > 1:
			usage()
			pass
		else:
			print("")
			print ("********************************************************************************************************")
			print()
			print("\t\t\t\tAlphanumeric Sub Encoder ")
			print("\t\t\t\t\t\t\t\t by: Abhilash Nigam")
			print()
			print ("********************************************************************************************************")

			print("1. Shellcode Encryption. ")
			print("2. Stack Alignment. ")
			ch = input("Enter choice:  ")
			if ch=="1":
				pass
				subEncoder()
				print (opCode)

			elif ch=="2":
				stackAlign()
				opCode += 'encoded += "\\x5C"\t\t\t\t\t\t#POP ESP\r\n'
				print (opCode)

			else:
				print ("Invalid Option Choosen")


	except Exception as e:
		usage()
